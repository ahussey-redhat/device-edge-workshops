{"ast":null,"code":"import * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = function (event, navigableElements) {\n  let isActiveElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : element => document.activeElement.contains(element);\n  let getFocusableElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : element => element;\n  let validSiblingTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['A', 'BUTTON', 'INPUT'];\n  let noVerticalArrowHandling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let noHorizontalArrowHandling = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let updateTabIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n  let onlyTraverseSiblings = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget = null;\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = options => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(option => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\nexport class KeyboardHandler extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.keyHandler = event => {\n      const {\n        isEventFromContainer\n      } = this.props;\n      // If the passed keyboard event is not from the container, ignore the event by returning\n      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n        return;\n      }\n      const {\n        isActiveElement,\n        getFocusableElement,\n        noVerticalArrowHandling,\n        noHorizontalArrowHandling,\n        noEnterHandling,\n        noSpaceHandling,\n        updateTabIndex,\n        validSiblingTags,\n        additionalKeyHandler,\n        createNavigableElements,\n        onlyTraverseSiblings\n      } = this.props;\n      // Pass the event off to be handled by any custom handler\n      additionalKeyHandler && additionalKeyHandler(event);\n      // Initalize navigableElements from the createNavigableElements callback\n      const navigableElements = createNavigableElements();\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n      const key = event.key;\n      // Handle enter key. If noEnterHandling is passed, skip this block\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Handle space key. If noSpaceHandling is passed, skip this block\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Inject helper handler for arrow navigation\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n    this._isEventFromContainer = event => {\n      const {\n        containerRef\n      } = this.props;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n  }\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n  render() {\n    return null;\n  }\n}\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: () => null,\n  isActiveElement: navigableElement => document.activeElement === navigableElement,\n  getFocusableElement: navigableElement => navigableElement,\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"names":["React","canUseDOM","handleArrows","event","navigableElements","isActiveElement","arguments","length","undefined","element","document","activeElement","contains","getFocusableElement","validSiblingTags","noVerticalArrowHandling","noHorizontalArrowHandling","updateTabIndex","onlyTraverseSiblings","key","moveTarget","includes","preventDefault","stopImmediatePropagation","currentIndex","forEach","index","increment","activeRow","querySelectorAll","join","nextSibling","previousElementSibling","nextElementSibling","tagName","focusableElement","target","tabIndex","focus","setTabIndex","options","option","KeyboardHandler","Component","constructor","keyHandler","isEventFromContainer","props","_isEventFromContainer","noEnterHandling","noSpaceHandling","additionalKeyHandler","createNavigableElements","console","warn","click","containerRef","current","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","render","displayName","defaultProps","navigableElement"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\@patternfly\\react-core\\src\\helpers\\KeyboardHandler.tsx"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n\nexport interface KeyboardHandlerProps {\n  /** Reference of the container to apply keyboard interaction */\n  containerRef: React.RefObject<any>;\n  /** Callback returning an array of navigable elements to be traversable via vertical arrow keys. This array should not include non-navigable elements such as disabled elements. */\n  createNavigableElements: () => Element[];\n  /** Callback to determine if a given event is from the container. By default the function conducts a basic check to see if the containerRef contains the event target */\n  isEventFromContainer?: (event: KeyboardEvent) => boolean;\n  /** Additional key handling outside of the included arrow keys, enter, and space handling */\n  additionalKeyHandler?: (event: KeyboardEvent) => void;\n  /** Callback to determine if a given element from the navigable elements array is the active element of the page */\n  isActiveElement?: (navigableElement: Element) => boolean;\n  /** Callback returning the focusable element of a given element from the navigable elements array */\n  getFocusableElement?: (navigableElement: Element) => Element;\n  /** Valid sibling tags that horizontal arrow handling will focus */\n  validSiblingTags?: string[];\n  /** Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex */\n  updateTabIndex?: boolean;\n  /** Flag indicating that next focusable element of a horizontal movement will be this element's sibling */\n  onlyTraverseSiblings?: boolean;\n  /** Flag indicating that the included vertical arrow key handling should be ignored */\n  noVerticalArrowHandling?: boolean;\n  /** Flag indicating that the included horizontal arrow key handling should be ignored */\n  noHorizontalArrowHandling?: boolean;\n  /** Flag indicating that the included enter key handling should be ignored */\n  noEnterHandling?: boolean;\n  /** Flag indicating that the included space key handling should be ignored */\n  noSpaceHandling?: boolean;\n}\n\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (\n  event: KeyboardEvent,\n  navigableElements: Element[],\n  isActiveElement: (element: Element) => boolean = element => document.activeElement.contains(element),\n  getFocusableElement: (element: Element) => Element = element => element,\n  validSiblingTags: string[] = ['A', 'BUTTON', 'INPUT'],\n  noVerticalArrowHandling: boolean = false,\n  noHorizontalArrowHandling: boolean = false,\n  updateTabIndex: boolean = true,\n  onlyTraverseSiblings: boolean = true\n) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget: Element = null;\n\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      (activeElement as HTMLElement).tabIndex = -1;\n      (moveTarget as HTMLElement).tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    (moveTarget as HTMLElement).focus();\n  }\n};\n\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options: HTMLElement[]) => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach((option: HTMLElement) => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\n\nexport class KeyboardHandler extends React.Component<KeyboardHandlerProps> {\n  static displayName = 'KeyboardHandler';\n  static defaultProps: KeyboardHandlerProps = {\n    containerRef: null,\n    createNavigableElements: () => null as Element[],\n    isActiveElement: (navigableElement: Element) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement: Element) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n  };\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  keyHandler = (event: KeyboardEvent) => {\n    const { isEventFromContainer } = this.props;\n    // If the passed keyboard event is not from the container, ignore the event by returning\n    if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n      return;\n    }\n\n    const {\n      isActiveElement,\n      getFocusableElement,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      noEnterHandling,\n      noSpaceHandling,\n      updateTabIndex,\n      validSiblingTags,\n      additionalKeyHandler,\n      createNavigableElements,\n      onlyTraverseSiblings\n    } = this.props;\n\n    // Pass the event off to be handled by any custom handler\n    additionalKeyHandler && additionalKeyHandler(event);\n\n    // Initalize navigableElements from the createNavigableElements callback\n    const navigableElements = createNavigableElements();\n    if (!navigableElements) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.'\n      );\n      return;\n    }\n    const key = event.key;\n\n    // Handle enter key. If noEnterHandling is passed, skip this block\n    if (!noEnterHandling) {\n      if (key === 'Enter') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Handle space key. If noSpaceHandling is passed, skip this block\n    if (!noSpaceHandling) {\n      if (key === ' ') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Inject helper handler for arrow navigation\n    handleArrows(\n      event,\n      navigableElements,\n      isActiveElement,\n      getFocusableElement,\n      validSiblingTags,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      updateTabIndex,\n      onlyTraverseSiblings\n    );\n  };\n\n  _isEventFromContainer = (event: KeyboardEvent) => {\n    const { containerRef } = this.props;\n    return containerRef.current && containerRef.current.contains(event.target as HTMLElement);\n  };\n\n  render() {\n    return null as React.ReactNode;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}