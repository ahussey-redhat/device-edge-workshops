{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { GenerateId } from '../../helpers';\nimport { flattenTree, flattenTreeWithFolders, filterFolders, filterTreeItems, filterTreeItemsWithoutFolders, filterRestTreeItems } from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\nexport class DualListSelector extends React.Component {\n  constructor(props) {\n    super(props);\n    this.addAllButtonRef = React.createRef();\n    this.addSelectedButtonRef = React.createRef();\n    this.removeSelectedButtonRef = React.createRef();\n    this.removeAllButtonRef = React.createRef();\n    /** In dev environment, prevents circular structure during JSON stringification when\n     * options passed in to the dual list selector include HTML elements.\n     */\n    this.replacer = (key, value) => {\n      if (key[0] === '_') {\n        return undefined;\n      }\n      return value;\n    };\n    this.onFilterUpdate = (newFilteredOptions, paneType, isSearchReset) => {\n      const {\n        isTree\n      } = this.props;\n      if (paneType === 'available') {\n        if (isSearchReset) {\n          this.setState({\n            availableFilteredOptions: null,\n            availableTreeFilteredOptions: null\n          });\n          return;\n        }\n        if (isTree) {\n          this.setState({\n            availableTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            availableFilteredOptions: newFilteredOptions\n          });\n        }\n      } else if (paneType === 'chosen') {\n        if (isSearchReset) {\n          this.setState({\n            chosenFilteredOptions: null,\n            chosenTreeFilteredOptions: null\n          });\n          return;\n        }\n        if (isTree) {\n          this.setState({\n            chosenTreeFilteredOptions: flattenTreeWithFolders(newFilteredOptions)\n          });\n        } else {\n          this.setState({\n            chosenFilteredOptions: newFilteredOptions\n          });\n        }\n      }\n    };\n    this.addAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n        prevState.availableOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n    this.addAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.availableTreeFilteredOptions || flattenTreeWithFolders(prevState.availableOptions);\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(movedOptions);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addAll && this.props.addAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n    this.addSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newAvailable = [];\n        prevState.availableOptions.forEach((value, index) => {\n          if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newAvailable.push(value);\n          }\n        });\n        const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable\n        };\n      });\n    };\n    this.addTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected available nodes from current available nodes\n        const newAvailable = prevState.availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.availableTreeOptionsChecked));\n        // Get next chosen options from current + new nodes and remap from base\n        const currChosen = flattenTree(prevState.chosenOptions);\n        const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n        const newChosen = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextChosenOptions));\n        this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n    this.removeAllVisible = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n        prevState.chosenOptions.forEach(value => {\n          if (movedOptions.indexOf(value) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable,\n          chosenOptionsSelected: [],\n          availableOptionsSelected: []\n        };\n      });\n    };\n    this.removeAllTreeVisible = () => {\n      this.setState(prevState => {\n        const movedOptions = prevState.chosenTreeFilteredOptions || flattenTreeWithFolders(prevState.chosenOptions);\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, movedOptions));\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(movedOptions);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptions: newChosen,\n          availableOptions: newAvailable,\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: []\n        };\n      });\n    };\n    this.removeSelected = () => {\n      this.setState(prevState => {\n        const itemsToRemove = [];\n        const newChosen = [];\n        prevState.chosenOptions.forEach((value, index) => {\n          if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n            itemsToRemove.push(value);\n          } else {\n            newChosen.push(value);\n          }\n        });\n        const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          chosenOptionsSelected: [],\n          availableOptionsSelected: [],\n          chosenOptions: newChosen,\n          chosenFilteredOptions: newChosen,\n          availableOptions: newAvailable,\n          availableFilteredOptions: newAvailable\n        };\n      });\n    };\n    this.removeTreeSelected = () => {\n      this.setState(prevState => {\n        // Remove selected chosen nodes from current chosen nodes\n        const newChosen = prevState.chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterRestTreeItems(item, prevState.chosenTreeOptionsChecked));\n        // Get next chosen options from current and remap from base\n        const currAvailable = flattenTree(prevState.availableOptions);\n        const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n        const newAvailable = this.createMergedCopy().map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, nextAvailableOptions));\n        this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n        this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n        return {\n          availableTreeOptionsChecked: [],\n          chosenTreeOptionsChecked: [],\n          availableOptions: newAvailable,\n          chosenOptions: newChosen\n        };\n      });\n    };\n    this.onOptionSelect = (e, index, isChosen, /* eslint-disable @typescript-eslint/no-unused-vars */\n    id, itemData, parentData\n    /* eslint-enable @typescript-eslint/no-unused-vars */) => {\n      this.setState(prevState => {\n        const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n        let updatedArray = null;\n        if (originalArray.indexOf(index) !== -1) {\n          updatedArray = originalArray.filter(value => value !== index);\n        } else {\n          updatedArray = [...originalArray, index];\n        }\n        return {\n          chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n          availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n        };\n      });\n      this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n    };\n    this.isChecked = (treeItem, isChosen) => isChosen ? this.state.chosenTreeOptionsChecked.includes(treeItem.id) : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n    this.areAllDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n    this.areSomeDescendantsChecked = (treeItem, isChosen) => treeItem.children ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen)) : this.isChecked(treeItem, isChosen);\n    this.mapChecked = (item, isChosen) => {\n      const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n      item.isChecked = false;\n      if (hasCheck) {\n        item.isChecked = true;\n      } else {\n        const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n        if (hasPartialCheck) {\n          item.isChecked = null;\n        }\n      }\n      if (item.children) {\n        return Object.assign(Object.assign({}, item), {\n          children: item.children.map(child => this.mapChecked(child, isChosen))\n        });\n      }\n      return item;\n    };\n    this.onTreeOptionCheck = (evt, isChecked, itemData, isChosen) => {\n      const {\n        availableOptions,\n        availableTreeFilteredOptions,\n        chosenOptions,\n        chosenTreeFilteredOptions\n      } = this.state;\n      let panelOptions;\n      if (isChosen) {\n        if (chosenTreeFilteredOptions) {\n          panelOptions = chosenOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, chosenTreeFilteredOptions));\n        } else {\n          panelOptions = chosenOptions;\n        }\n      } else {\n        if (availableTreeFilteredOptions) {\n          panelOptions = availableOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItemsWithoutFolders(item, availableTreeFilteredOptions));\n        } else {\n          panelOptions = availableOptions;\n        }\n      }\n      const checkedOptionTree = panelOptions.map(opt => Object.assign({}, opt)).filter(item => filterTreeItems(item, [itemData.id]));\n      const flatTree = flattenTreeWithFolders(checkedOptionTree);\n      const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n      let updatedChecked = [];\n      if (isChecked) {\n        updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n      } else {\n        updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n      }\n      this.setState(prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }), () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      });\n    };\n    this.state = {\n      availableOptions: [...this.props.availableOptions],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  }\n  // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n  createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n    return this.props.isTree ? Object.values(copyOfAvailable.concat(copyOfChosen).reduce((mapObj, item) => {\n      const key = item.id;\n      if (mapObj[key]) {\n        // If map already has an item ID, add the dupe ID's children to the existing map\n        mapObj[key].children.push(...item.children);\n      } else {\n        // Else clone the item data\n        mapObj[key] = Object.assign({}, item);\n      }\n      return mapObj;\n    }, {})) : null;\n  }\n  componentDidUpdate() {\n    if (JSON.stringify(this.props.availableOptions, this.replacer) !== JSON.stringify(this.state.availableOptions, this.replacer) || JSON.stringify(this.props.chosenOptions, this.replacer) !== JSON.stringify(this.state.chosenOptions, this.replacer)) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions],\n        chosenOptions: [...this.props.chosenOptions]\n      });\n    }\n  }\n  render() {\n    const _a = this.props,\n      {\n        availableOptionsTitle,\n        availableOptionsActions,\n        availableOptionsSearchAriaLabel,\n        className,\n        children,\n        chosenOptionsTitle,\n        chosenOptionsActions,\n        chosenOptionsSearchAriaLabel,\n        filterOption,\n        isSearchable,\n        chosenOptionsStatus,\n        availableOptionsStatus,\n        controlsAriaLabel,\n        addAllAriaLabel,\n        addSelectedAriaLabel,\n        removeSelectedAriaLabel,\n        removeAllAriaLabel,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        availableOptions: consumerPassedAvailableOptions,\n        chosenOptions: consumerPassedChosenOptions,\n        removeSelected,\n        addAll,\n        removeAll,\n        addSelected,\n        onListChange,\n        onAvailableOptionsSearchInputChanged,\n        onChosenOptionsSearchInputChanged,\n        onOptionSelect,\n        onOptionCheck,\n        id,\n        isTree,\n        isDisabled,\n        addAllTooltip,\n        addAllTooltipProps,\n        addSelectedTooltip,\n        addSelectedTooltipProps,\n        removeAllTooltip,\n        removeAllTooltipProps,\n        removeSelectedTooltip,\n        removeSelectedTooltipProps\n      } = _a,\n      props = __rest(_a, [\"availableOptionsTitle\", \"availableOptionsActions\", \"availableOptionsSearchAriaLabel\", \"className\", \"children\", \"chosenOptionsTitle\", \"chosenOptionsActions\", \"chosenOptionsSearchAriaLabel\", \"filterOption\", \"isSearchable\", \"chosenOptionsStatus\", \"availableOptionsStatus\", \"controlsAriaLabel\", \"addAllAriaLabel\", \"addSelectedAriaLabel\", \"removeSelectedAriaLabel\", \"removeAllAriaLabel\", \"availableOptions\", \"chosenOptions\", \"removeSelected\", \"addAll\", \"removeAll\", \"addSelected\", \"onListChange\", \"onAvailableOptionsSearchInputChanged\", \"onChosenOptionsSearchInputChanged\", \"onOptionSelect\", \"onOptionCheck\", \"id\", \"isTree\", \"isDisabled\", \"addAllTooltip\", \"addAllTooltipProps\", \"addSelectedTooltip\", \"addSelectedTooltipProps\", \"removeAllTooltip\", \"removeAllTooltipProps\", \"removeSelectedTooltip\", \"removeSelectedTooltipProps\"]);\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay = availableOptionsStatus || (isTree ? `${filterFolders(availableOptions, availableTreeOptionsChecked).length} of ${flattenTree(availableOptions).length} items selected` : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay = chosenOptionsStatus || (isTree ? `${filterFolders(chosenOptions, chosenTreeOptionsChecked).length} of ${flattenTree(chosenOptions).length} items selected` : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n    const available = isTree ? availableOptions.map(item => this.mapChecked(item, false)) : availableOptions;\n    const chosen = isTree ? chosenOptions.map(item => this.mapChecked(item, true)) : chosenOptions;\n    return React.createElement(DualListSelectorContext.Provider, {\n      value: {\n        isTree\n      }\n    }, React.createElement(GenerateId, null, randomId => React.createElement(\"div\", Object.assign({\n      className: css(styles.dualListSelector, className),\n      id: id || randomId\n    }, props), children === '' ? React.createElement(React.Fragment, null, React.createElement(DualListSelectorPane, {\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: availableOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onAvailableOptionsSearchInputChanged,\n      status: availableOptionsStatusToDisplay,\n      title: availableOptionsTitle,\n      options: available,\n      selectedOptions: isTree ? availableTreeOptionsChecked : availableOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false),\n      actions: availableOptionsActions,\n      id: `${id || randomId}-available-pane`,\n      isDisabled: isDisabled\n    }), React.createElement(DualListSelectorControlsWrapper, {\n      \"aria-label\": controlsAriaLabel\n    }, React.createElement(DualListSelectorControl, {\n      isDisabled: (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) || isDisabled,\n      onClick: isTree ? this.addTreeSelected : this.addSelected,\n      ref: this.addSelectedButtonRef,\n      \"aria-label\": addSelectedAriaLabel,\n      tooltipContent: addSelectedTooltip,\n      tooltipProps: addSelectedTooltipProps\n    }, React.createElement(AngleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: availableOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.addAllTreeVisible : this.addAllVisible,\n      ref: this.addAllButtonRef,\n      \"aria-label\": addAllAriaLabel,\n      tooltipContent: addAllTooltip,\n      tooltipProps: addAllTooltipProps\n    }, React.createElement(AngleDoubleRightIcon, null)), React.createElement(DualListSelectorControl, {\n      isDisabled: chosenOptions.length === 0 || isDisabled,\n      onClick: isTree ? this.removeAllTreeVisible : this.removeAllVisible,\n      \"aria-label\": removeAllAriaLabel,\n      ref: this.removeAllButtonRef,\n      tooltipContent: removeAllTooltip,\n      tooltipProps: removeAllTooltipProps\n    }, React.createElement(AngleDoubleLeftIcon, null)), React.createElement(DualListSelectorControl, {\n      onClick: isTree ? this.removeTreeSelected : this.removeSelected,\n      isDisabled: (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) || isDisabled,\n      ref: this.removeSelectedButtonRef,\n      \"aria-label\": removeSelectedAriaLabel,\n      tooltipContent: removeSelectedTooltip,\n      tooltipProps: removeSelectedTooltipProps\n    }, React.createElement(AngleLeftIcon, null))), React.createElement(DualListSelectorPane, {\n      isChosen: true,\n      isSearchable: isSearchable,\n      onFilterUpdate: this.onFilterUpdate,\n      searchInputAriaLabel: chosenOptionsSearchAriaLabel,\n      filterOption: filterOption,\n      onSearchInputChanged: onChosenOptionsSearchInputChanged,\n      title: chosenOptionsTitle,\n      status: chosenOptionsStatusToDisplay,\n      options: chosen,\n      selectedOptions: isTree ? chosenTreeOptionsChecked : chosenOptionsSelected,\n      onOptionSelect: this.onOptionSelect,\n      onOptionCheck: (e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true),\n      actions: chosenOptionsActions,\n      id: `${id || randomId}-chosen-pane`,\n      isDisabled: isDisabled\n    })) : children)));\n  }\n}\nDualListSelector.displayName = 'DualListSelector';\nDualListSelector.defaultProps = {\n  children: '',\n  availableOptions: [],\n  availableOptionsTitle: 'Available options',\n  availableOptionsSearchAriaLabel: 'Available search input',\n  chosenOptions: [],\n  chosenOptionsTitle: 'Chosen options',\n  chosenOptionsSearchAriaLabel: 'Chosen search input',\n  controlsAriaLabel: 'Selector controls',\n  addAllAriaLabel: 'Add all',\n  addSelectedAriaLabel: 'Add selected',\n  removeSelectedAriaLabel: 'Remove selected',\n  removeAllAriaLabel: 'Remove all',\n  isTree: false,\n  isDisabled: false\n};","map":{"version":3,"names":["React","styles","css","AngleDoubleLeftIcon","AngleLeftIcon","AngleDoubleRightIcon","AngleRightIcon","DualListSelectorPane","GenerateId","flattenTree","flattenTreeWithFolders","filterFolders","filterTreeItems","filterTreeItemsWithoutFolders","filterRestTreeItems","DualListSelectorControlsWrapper","DualListSelectorControl","DualListSelectorContext","DualListSelector","Component","constructor","props","addAllButtonRef","createRef","addSelectedButtonRef","removeSelectedButtonRef","removeAllButtonRef","replacer","key","value","undefined","onFilterUpdate","newFilteredOptions","paneType","isSearchReset","isTree","setState","availableFilteredOptions","availableTreeFilteredOptions","chosenFilteredOptions","chosenTreeFilteredOptions","addAllVisible","prevState","itemsToRemove","newAvailable","movedOptions","availableOptions","forEach","indexOf","push","newChosen","chosenOptions","addAll","onListChange","chosenOptionsSelected","availableOptionsSelected","addAllTreeVisible","map","opt","Object","assign","filter","item","currChosen","nextChosenOptions","concat","createMergedCopy","availableTreeOptionsChecked","chosenTreeOptionsChecked","addSelected","index","addTreeSelected","removeAllVisible","removeAll","removeAllTreeVisible","currAvailable","nextAvailableOptions","removeSelected","removeTreeSelected","onOptionSelect","e","isChosen","id","itemData","parentData","originalArray","updatedArray","isChecked","treeItem","state","includes","areAllDescendantsChecked","children","every","child","areSomeDescendantsChecked","some","mapChecked","hasCheck","hasPartialCheck","onTreeOptionCheck","evt","panelOptions","checkedOptionTree","flatTree","prevChecked","updatedChecked","onOptionCheck","copyOfAvailable","JSON","parse","stringify","copyOfChosen","values","reduce","mapObj","componentDidUpdate","render","_a","availableOptionsTitle","availableOptionsActions","availableOptionsSearchAriaLabel","className","chosenOptionsTitle","chosenOptionsActions","chosenOptionsSearchAriaLabel","filterOption","isSearchable","chosenOptionsStatus","availableOptionsStatus","controlsAriaLabel","addAllAriaLabel","addSelectedAriaLabel","removeSelectedAriaLabel","removeAllAriaLabel","consumerPassedAvailableOptions","consumerPassedChosenOptions","onAvailableOptionsSearchInputChanged","onChosenOptionsSearchInputChanged","isDisabled","addAllTooltip","addAllTooltipProps","addSelectedTooltip","addSelectedTooltipProps","removeAllTooltip","removeAllTooltipProps","removeSelectedTooltip","removeSelectedTooltipProps","__rest","availableOptionsStatusToDisplay","length","chosenOptionsStatusToDisplay","available","chosen","createElement","Provider","randomId","dualListSelector","Fragment","searchInputAriaLabel","onSearchInputChanged","status","title","options","selectedOptions","actions","onClick","ref","tooltipContent","tooltipProps","displayName","defaultProps"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\@patternfly\\react-core\\src\\components\\DualListSelector\\DualListSelector.tsx"],"sourcesContent":["import * as React from 'react';\nimport styles from '@patternfly/react-styles/css/components/DualListSelector/dual-list-selector';\nimport { css } from '@patternfly/react-styles';\nimport AngleDoubleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-left-icon';\nimport AngleLeftIcon from '@patternfly/react-icons/dist/esm/icons/angle-left-icon';\nimport AngleDoubleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-double-right-icon';\nimport AngleRightIcon from '@patternfly/react-icons/dist/esm/icons/angle-right-icon';\nimport { DualListSelectorPane } from './DualListSelectorPane';\nimport { GenerateId, PickOptional } from '../../helpers';\nimport { DualListSelectorTreeItemData } from './DualListSelectorTree';\nimport {\n  flattenTree,\n  flattenTreeWithFolders,\n  filterFolders,\n  filterTreeItems,\n  filterTreeItemsWithoutFolders,\n  filterRestTreeItems\n} from './treeUtils';\nimport { DualListSelectorControlsWrapper } from './DualListSelectorControlsWrapper';\nimport { DualListSelectorControl } from './DualListSelectorControl';\nimport { DualListSelectorContext } from './DualListSelectorContext';\n\n/** Acts as a container for all other DualListSelector sub-components when using a\n * composable dual list selector.\n */\n\nexport interface DualListSelectorProps {\n  /** Additional classes applied to the dual list selector. */\n  className?: string;\n  /** Id of the dual list selector. */\n  id?: string;\n  /** Flag indicating if the dual list selector uses trees instead of simple lists */\n  isTree?: boolean;\n  /** Flag indicating if the dual list selector is in a disabled state */\n  isDisabled?: boolean;\n  /** Content to be rendered in the dual list selector. Panes & controls will not be built dynamically when children are provided. */\n  children?: React.ReactNode;\n  /** Title applied to the dynamically built available options pane. */\n  availableOptionsTitle?: string;\n  /** Options to display in the dynamically built available options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  availableOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built available options pane. */\n  availableOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built available options pane. */\n  availableOptionsActions?: React.ReactNode[];\n  /** Title applied to the dynamically built chosen options pane. */\n  chosenOptionsTitle?: string;\n  /** Options to display in the dynamically built chosen options pane. When using trees, the options should be in the DualListSelectorTreeItemData[] format. */\n  chosenOptions?: React.ReactNode[] | DualListSelectorTreeItemData[];\n  /** Status message to display above the dynamically built chosen options pane.*/\n  chosenOptionsStatus?: string;\n  /** Actions to be displayed above the dynamically built chosen options pane. */\n  chosenOptionsActions?: React.ReactNode[];\n  /** Accessible label for the dynamically built controls between the two panes. */\n  controlsAriaLabel?: string;\n  /** Optional callback for the dynamically built add selected button */\n  addSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add selected button */\n  addSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built add selected button */\n  addSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add selected tooltip */\n  addSelectedTooltipProps?: any;\n  /** Callback fired every time dynamically built options are chosen or removed */\n  onListChange?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Optional callback for the dynamically built add all button */\n  addAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built add all button */\n  addAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built add all button */\n  addAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built add all tooltip */\n  addAllTooltipProps?: any;\n  /** Optional callback for the dynamically built remove selected button */\n  removeSelected?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove selected button */\n  removeSelectedAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove selected button */\n  removeSelectedTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove selected tooltip  */\n  removeSelectedTooltipProps?: any;\n  /** Optional callback for the dynamically built remove all button */\n  removeAll?: (newAvailableOptions: React.ReactNode[], newChosenOptions: React.ReactNode[]) => void;\n  /** Accessible label for the dynamically built remove all button */\n  removeAllAriaLabel?: string;\n  /** Tooltip content for the dynamically built remove all button */\n  removeAllTooltip?: React.ReactNode;\n  /** Additonal tooltip properties for the dynamically built remove all tooltip */\n  removeAllTooltipProps?: any;\n  /** Optional callback fired when a dynamically built option is selected */\n  onOptionSelect?: (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    id: string,\n    itemData: any,\n    parentData: any\n  ) => void;\n  /** Optional callback fired when a dynamically built option is checked */\n  onOptionCheck?: (\n    e: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    checked: boolean,\n    checkedId: string,\n    newCheckedItems: string[]\n  ) => void;\n  /** Flag indicating a search bar should be included above both the dynamically built available and chosen panes. */\n  isSearchable?: boolean;\n  /** Accessible label for the search input on the dynamically built available options pane. */\n  availableOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built available options changes. */\n  onAvailableOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Accessible label for the search input on the dynamically built chosen options pane. */\n  chosenOptionsSearchAriaLabel?: string;\n  /** A callback for when the search input value for the dynamically built chosen options changes. */\n  onChosenOptionsSearchInputChanged?: (value: string, event: React.FormEvent<HTMLInputElement>) => void;\n  /** Optional filter function for custom filtering based on search string. Used with a dynamically built search input. */\n  filterOption?: (option: React.ReactNode, input: string) => boolean;\n}\n\ninterface DualListSelectorState {\n  availableOptions: React.ReactNode[];\n  availableOptionsSelected: number[];\n  availableFilteredOptions: React.ReactNode[];\n  chosenOptions: React.ReactNode[];\n  chosenOptionsSelected: number[];\n  chosenFilteredOptions: React.ReactNode[];\n  availableTreeFilteredOptions: string[];\n  availableTreeOptionsChecked: string[];\n  chosenTreeOptionsChecked: string[];\n  chosenTreeFilteredOptions: string[];\n}\n\nexport class DualListSelector extends React.Component<DualListSelectorProps, DualListSelectorState> {\n  static displayName = 'DualListSelector';\n  private addAllButtonRef = React.createRef<HTMLButtonElement>();\n  private addSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeSelectedButtonRef = React.createRef<HTMLButtonElement>();\n  private removeAllButtonRef = React.createRef<HTMLButtonElement>();\n  static defaultProps: PickOptional<DualListSelectorProps> = {\n    children: '',\n    availableOptions: [],\n    availableOptionsTitle: 'Available options',\n    availableOptionsSearchAriaLabel: 'Available search input',\n    chosenOptions: [],\n    chosenOptionsTitle: 'Chosen options',\n    chosenOptionsSearchAriaLabel: 'Chosen search input',\n    controlsAriaLabel: 'Selector controls',\n    addAllAriaLabel: 'Add all',\n    addSelectedAriaLabel: 'Add selected',\n    removeSelectedAriaLabel: 'Remove selected',\n    removeAllAriaLabel: 'Remove all',\n    isTree: false,\n    isDisabled: false\n  };\n\n  // If the DualListSelector uses trees, concat the two initial arrays and merge duplicate folder IDs\n  private createMergedCopy() {\n    const copyOfAvailable = JSON.parse(JSON.stringify(this.props.availableOptions));\n    const copyOfChosen = JSON.parse(JSON.stringify(this.props.chosenOptions));\n\n    return this.props.isTree\n      ? Object.values(\n          (copyOfAvailable as DualListSelectorTreeItemData[])\n            .concat(copyOfChosen as DualListSelectorTreeItemData[])\n            .reduce((mapObj: any, item: DualListSelectorTreeItemData) => {\n              const key = item.id;\n              if (mapObj[key]) {\n                // If map already has an item ID, add the dupe ID's children to the existing map\n                mapObj[key].children.push(...item.children);\n              } else {\n                // Else clone the item data\n                mapObj[key] = { ...item };\n              }\n              return mapObj;\n            }, {})\n        )\n      : null;\n  }\n\n  constructor(props: DualListSelectorProps) {\n    super(props);\n    this.state = {\n      availableOptions: [...this.props.availableOptions] as React.ReactNode[],\n      availableOptionsSelected: [],\n      availableFilteredOptions: null,\n      availableTreeFilteredOptions: null,\n      chosenOptions: [...this.props.chosenOptions] as React.ReactNode[],\n      chosenOptionsSelected: [],\n      chosenFilteredOptions: null,\n      chosenTreeFilteredOptions: null,\n      availableTreeOptionsChecked: [],\n      chosenTreeOptionsChecked: []\n    };\n  }\n\n  /** In dev environment, prevents circular structure during JSON stringification when\n   * options passed in to the dual list selector include HTML elements.\n   */\n  replacer = (key: string, value: any) => {\n    if (key[0] === '_') {\n      return undefined;\n    }\n    return value;\n  };\n\n  componentDidUpdate() {\n    if (\n      JSON.stringify(this.props.availableOptions, this.replacer) !==\n        JSON.stringify(this.state.availableOptions, this.replacer) ||\n      JSON.stringify(this.props.chosenOptions, this.replacer) !==\n        JSON.stringify(this.state.chosenOptions, this.replacer)\n    ) {\n      this.setState({\n        availableOptions: [...this.props.availableOptions] as React.ReactNode[],\n        chosenOptions: [...this.props.chosenOptions] as React.ReactNode[]\n      });\n    }\n  }\n\n  onFilterUpdate = (newFilteredOptions: React.ReactNode[], paneType: string, isSearchReset: boolean) => {\n    const { isTree } = this.props;\n    if (paneType === 'available') {\n      if (isSearchReset) {\n        this.setState({\n          availableFilteredOptions: null,\n          availableTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          availableTreeFilteredOptions: flattenTreeWithFolders(\n            (newFilteredOptions as unknown) as DualListSelectorTreeItemData[]\n          )\n        });\n      } else {\n        this.setState({\n          availableFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    } else if (paneType === 'chosen') {\n      if (isSearchReset) {\n        this.setState({\n          chosenFilteredOptions: null,\n          chosenTreeFilteredOptions: null\n        });\n        return;\n      }\n      if (isTree) {\n        this.setState({\n          chosenTreeFilteredOptions: flattenTreeWithFolders(\n            (newFilteredOptions as unknown) as DualListSelectorTreeItemData[]\n          )\n        });\n      } else {\n        this.setState({\n          chosenFilteredOptions: newFilteredOptions as React.ReactNode[]\n        });\n      }\n    }\n  };\n\n  addAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      const movedOptions = prevState.availableFilteredOptions || prevState.availableOptions;\n      prevState.availableOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  addAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.availableTreeFilteredOptions ||\n        flattenTreeWithFolders((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, movedOptions)\n        ) as React.ReactNode[];\n\n      const currChosen = flattenTree((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(movedOptions);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions)\n        ) as React.ReactNode[];\n\n      this.props.addAll && this.props.addAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  addSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newAvailable = [] as React.ReactNode[];\n      prevState.availableOptions.forEach((value, index) => {\n        if (prevState.availableOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newAvailable.push(value);\n        }\n      });\n\n      const newChosen = [...prevState.chosenOptions, ...itemsToRemove];\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable\n      };\n    });\n  };\n\n  addTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected available nodes from current available nodes\n      const newAvailable = prevState.availableOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, prevState.availableTreeOptionsChecked)\n        );\n\n      // Get next chosen options from current + new nodes and remap from base\n      const currChosen = flattenTree((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextChosenOptions = currChosen.concat(prevState.availableTreeOptionsChecked);\n      const newChosen = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextChosenOptions)\n        ) as React.ReactNode[];\n\n      this.props.addSelected && this.props.addSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  removeAllVisible = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      const movedOptions = prevState.chosenFilteredOptions || prevState.chosenOptions;\n      prevState.chosenOptions.forEach(value => {\n        if (movedOptions.indexOf(value) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable,\n        chosenOptionsSelected: [],\n        availableOptionsSelected: []\n      };\n    });\n  };\n\n  removeAllTreeVisible = () => {\n    this.setState(prevState => {\n      const movedOptions =\n        prevState.chosenTreeFilteredOptions ||\n        flattenTreeWithFolders((prevState.chosenOptions as unknown) as DualListSelectorTreeItemData[]);\n\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item => filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, movedOptions));\n      const currAvailable = flattenTree((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(movedOptions);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions)\n        ) as React.ReactNode[];\n\n      this.props.removeAll && this.props.removeAll(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptions: newChosen,\n        availableOptions: newAvailable,\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: []\n      };\n    });\n  };\n\n  removeSelected = () => {\n    this.setState(prevState => {\n      const itemsToRemove = [] as React.ReactNode[];\n      const newChosen = [] as React.ReactNode[];\n      prevState.chosenOptions.forEach((value, index) => {\n        if (prevState.chosenOptionsSelected.indexOf(index) !== -1) {\n          itemsToRemove.push(value);\n        } else {\n          newChosen.push(value);\n        }\n      });\n\n      const newAvailable = [...prevState.availableOptions, ...itemsToRemove];\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        chosenOptionsSelected: [],\n        availableOptionsSelected: [],\n        chosenOptions: newChosen,\n        chosenFilteredOptions: newChosen,\n        availableOptions: newAvailable,\n        availableFilteredOptions: newAvailable\n      };\n    });\n  };\n\n  removeTreeSelected = () => {\n    this.setState(prevState => {\n      // Remove selected chosen nodes from current chosen nodes\n      const newChosen = prevState.chosenOptions\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterRestTreeItems((item as unknown) as DualListSelectorTreeItemData, prevState.chosenTreeOptionsChecked)\n        );\n\n      // Get next chosen options from current and remap from base\n      const currAvailable = flattenTree((prevState.availableOptions as unknown) as DualListSelectorTreeItemData[]);\n      const nextAvailableOptions = currAvailable.concat(prevState.chosenTreeOptionsChecked);\n      const newAvailable = this.createMergedCopy()\n        .map(opt => Object.assign({}, opt))\n        .filter(item =>\n          filterTreeItemsWithoutFolders(item as DualListSelectorTreeItemData, nextAvailableOptions)\n        ) as React.ReactNode[];\n\n      this.props.removeSelected && this.props.removeSelected(newAvailable, newChosen);\n      this.props.onListChange && this.props.onListChange(newAvailable, newChosen);\n\n      return {\n        availableTreeOptionsChecked: [],\n        chosenTreeOptionsChecked: [],\n        availableOptions: newAvailable,\n        chosenOptions: newChosen\n      };\n    });\n  };\n\n  onOptionSelect = (\n    e: React.MouseEvent | React.ChangeEvent | React.KeyboardEvent,\n    index: number,\n    isChosen: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    id?: string,\n    itemData?: any,\n    parentData?: any\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ) => {\n    this.setState(prevState => {\n      const originalArray = isChosen ? prevState.chosenOptionsSelected : prevState.availableOptionsSelected;\n\n      let updatedArray = null;\n      if (originalArray.indexOf(index) !== -1) {\n        updatedArray = originalArray.filter(value => value !== index);\n      } else {\n        updatedArray = [...originalArray, index];\n      }\n\n      return {\n        chosenOptionsSelected: isChosen ? updatedArray : prevState.chosenOptionsSelected,\n        availableOptionsSelected: isChosen ? prevState.availableOptionsSelected : updatedArray\n      };\n    });\n\n    this.props.onOptionSelect && this.props.onOptionSelect(e, index, isChosen, id, itemData, parentData);\n  };\n\n  isChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean) =>\n    isChosen\n      ? this.state.chosenTreeOptionsChecked.includes(treeItem.id)\n      : this.state.availableTreeOptionsChecked.includes(treeItem.id);\n  areAllDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.every(child => this.areAllDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n  areSomeDescendantsChecked = (treeItem: DualListSelectorTreeItemData, isChosen: boolean): boolean =>\n    treeItem.children\n      ? treeItem.children.some(child => this.areSomeDescendantsChecked(child, isChosen))\n      : this.isChecked(treeItem, isChosen);\n\n  mapChecked = (item: DualListSelectorTreeItemData, isChosen: boolean): DualListSelectorTreeItemData => {\n    const hasCheck = this.areAllDescendantsChecked(item, isChosen);\n    item.isChecked = false;\n\n    if (hasCheck) {\n      item.isChecked = true;\n    } else {\n      const hasPartialCheck = this.areSomeDescendantsChecked(item, isChosen);\n      if (hasPartialCheck) {\n        item.isChecked = null;\n      }\n    }\n\n    if (item.children) {\n      return {\n        ...item,\n        children: item.children.map(child => this.mapChecked(child, isChosen))\n      };\n    }\n    return item;\n  };\n\n  onTreeOptionCheck = (\n    evt: React.MouseEvent | React.ChangeEvent<HTMLInputElement> | React.KeyboardEvent,\n    isChecked: boolean,\n    itemData: DualListSelectorTreeItemData,\n    isChosen: boolean\n  ) => {\n    const { availableOptions, availableTreeFilteredOptions, chosenOptions, chosenTreeFilteredOptions } = this.state;\n    let panelOptions;\n    if (isChosen) {\n      if (chosenTreeFilteredOptions) {\n        panelOptions = chosenOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders((item as unknown) as DualListSelectorTreeItemData, chosenTreeFilteredOptions)\n          );\n      } else {\n        panelOptions = chosenOptions;\n      }\n    } else {\n      if (availableTreeFilteredOptions) {\n        panelOptions = availableOptions\n          .map(opt => Object.assign({}, opt))\n          .filter(item =>\n            filterTreeItemsWithoutFolders(\n              (item as unknown) as DualListSelectorTreeItemData,\n              availableTreeFilteredOptions\n            )\n          );\n      } else {\n        panelOptions = availableOptions;\n      }\n    }\n    const checkedOptionTree = panelOptions\n      .map(opt => Object.assign({}, opt))\n      .filter(item => filterTreeItems((item as unknown) as DualListSelectorTreeItemData, [itemData.id]));\n    const flatTree = flattenTreeWithFolders((checkedOptionTree as unknown) as DualListSelectorTreeItemData[]);\n\n    const prevChecked = isChosen ? this.state.chosenTreeOptionsChecked : this.state.availableTreeOptionsChecked;\n    let updatedChecked = [] as string[];\n    if (isChecked) {\n      updatedChecked = prevChecked.concat(flatTree.filter(id => !prevChecked.includes(id)));\n    } else {\n      updatedChecked = prevChecked.filter(id => !flatTree.includes(id));\n    }\n\n    this.setState(\n      prevState => ({\n        availableTreeOptionsChecked: isChosen ? prevState.availableTreeOptionsChecked : updatedChecked,\n        chosenTreeOptionsChecked: isChosen ? updatedChecked : prevState.chosenTreeOptionsChecked\n      }),\n      () => {\n        this.props.onOptionCheck && this.props.onOptionCheck(evt, isChecked, itemData.id, updatedChecked);\n      }\n    );\n  };\n\n  render() {\n    const {\n      availableOptionsTitle,\n      availableOptionsActions,\n      availableOptionsSearchAriaLabel,\n      className,\n      children,\n      chosenOptionsTitle,\n      chosenOptionsActions,\n      chosenOptionsSearchAriaLabel,\n      filterOption,\n      isSearchable,\n      chosenOptionsStatus,\n      availableOptionsStatus,\n      controlsAriaLabel,\n      addAllAriaLabel,\n      addSelectedAriaLabel,\n      removeSelectedAriaLabel,\n      removeAllAriaLabel,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      availableOptions: consumerPassedAvailableOptions,\n      chosenOptions: consumerPassedChosenOptions,\n      removeSelected,\n      addAll,\n      removeAll,\n      addSelected,\n      onListChange,\n      onAvailableOptionsSearchInputChanged,\n      onChosenOptionsSearchInputChanged,\n      onOptionSelect,\n      onOptionCheck,\n      id,\n      isTree,\n      isDisabled,\n      addAllTooltip,\n      addAllTooltipProps,\n      addSelectedTooltip,\n      addSelectedTooltipProps,\n      removeAllTooltip,\n      removeAllTooltipProps,\n      removeSelectedTooltip,\n      removeSelectedTooltipProps,\n      ...props\n    } = this.props;\n    const {\n      availableOptions,\n      chosenOptions,\n      chosenOptionsSelected,\n      availableOptionsSelected,\n      chosenTreeOptionsChecked,\n      availableTreeOptionsChecked\n    } = this.state;\n    const availableOptionsStatusToDisplay =\n      availableOptionsStatus ||\n      (isTree\n        ? `${\n            filterFolders((availableOptions as unknown) as DualListSelectorTreeItemData[], availableTreeOptionsChecked)\n              .length\n          } of ${flattenTree((availableOptions as unknown) as DualListSelectorTreeItemData[]).length} items selected`\n        : `${availableOptionsSelected.length} of ${availableOptions.length} items selected`);\n    const chosenOptionsStatusToDisplay =\n      chosenOptionsStatus ||\n      (isTree\n        ? `${\n            filterFolders((chosenOptions as unknown) as DualListSelectorTreeItemData[], chosenTreeOptionsChecked).length\n          } of ${flattenTree((chosenOptions as unknown) as DualListSelectorTreeItemData[]).length} items selected`\n        : `${chosenOptionsSelected.length} of ${chosenOptions.length} items selected`);\n\n    const available = (isTree\n      ? availableOptions.map(item => this.mapChecked((item as unknown) as DualListSelectorTreeItemData, false))\n      : availableOptions) as React.ReactNode[];\n    const chosen = (isTree\n      ? chosenOptions.map(item => this.mapChecked((item as unknown) as DualListSelectorTreeItemData, true))\n      : chosenOptions) as React.ReactNode[];\n\n    return (\n      <DualListSelectorContext.Provider value={{ isTree }}>\n        <GenerateId>\n          {randomId => (\n            <div className={css(styles.dualListSelector, className)} id={id || randomId} {...props}>\n              {children === '' ? (\n                <>\n                  <DualListSelectorPane\n                    isSearchable={isSearchable}\n                    onFilterUpdate={this.onFilterUpdate}\n                    searchInputAriaLabel={availableOptionsSearchAriaLabel}\n                    filterOption={filterOption}\n                    onSearchInputChanged={onAvailableOptionsSearchInputChanged}\n                    status={availableOptionsStatusToDisplay}\n                    title={availableOptionsTitle}\n                    options={available}\n                    selectedOptions={isTree ? availableTreeOptionsChecked : availableOptionsSelected}\n                    onOptionSelect={this.onOptionSelect}\n                    onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, false)}\n                    actions={availableOptionsActions}\n                    id={`${id || randomId}-available-pane`}\n                    isDisabled={isDisabled}\n                  />\n                  <DualListSelectorControlsWrapper aria-label={controlsAriaLabel}>\n                    <DualListSelectorControl\n                      isDisabled={\n                        (isTree ? availableTreeOptionsChecked.length === 0 : availableOptionsSelected.length === 0) ||\n                        isDisabled\n                      }\n                      onClick={isTree ? this.addTreeSelected : this.addSelected}\n                      ref={this.addSelectedButtonRef}\n                      aria-label={addSelectedAriaLabel}\n                      tooltipContent={addSelectedTooltip}\n                      tooltipProps={addSelectedTooltipProps}\n                    >\n                      <AngleRightIcon />\n                    </DualListSelectorControl>\n                    <DualListSelectorControl\n                      isDisabled={availableOptions.length === 0 || isDisabled}\n                      onClick={isTree ? this.addAllTreeVisible : this.addAllVisible}\n                      ref={this.addAllButtonRef}\n                      aria-label={addAllAriaLabel}\n                      tooltipContent={addAllTooltip}\n                      tooltipProps={addAllTooltipProps}\n                    >\n                      <AngleDoubleRightIcon />\n                    </DualListSelectorControl>\n                    <DualListSelectorControl\n                      isDisabled={chosenOptions.length === 0 || isDisabled}\n                      onClick={isTree ? this.removeAllTreeVisible : this.removeAllVisible}\n                      aria-label={removeAllAriaLabel}\n                      ref={this.removeAllButtonRef}\n                      tooltipContent={removeAllTooltip}\n                      tooltipProps={removeAllTooltipProps}\n                    >\n                      <AngleDoubleLeftIcon />\n                    </DualListSelectorControl>\n                    <DualListSelectorControl\n                      onClick={isTree ? this.removeTreeSelected : this.removeSelected}\n                      isDisabled={\n                        (isTree ? chosenTreeOptionsChecked.length === 0 : chosenOptionsSelected.length === 0) ||\n                        isDisabled\n                      }\n                      ref={this.removeSelectedButtonRef}\n                      aria-label={removeSelectedAriaLabel}\n                      tooltipContent={removeSelectedTooltip}\n                      tooltipProps={removeSelectedTooltipProps}\n                    >\n                      <AngleLeftIcon />\n                    </DualListSelectorControl>\n                  </DualListSelectorControlsWrapper>\n                  <DualListSelectorPane\n                    isChosen\n                    isSearchable={isSearchable}\n                    onFilterUpdate={this.onFilterUpdate}\n                    searchInputAriaLabel={chosenOptionsSearchAriaLabel}\n                    filterOption={filterOption}\n                    onSearchInputChanged={onChosenOptionsSearchInputChanged}\n                    title={chosenOptionsTitle}\n                    status={chosenOptionsStatusToDisplay}\n                    options={chosen}\n                    selectedOptions={isTree ? chosenTreeOptionsChecked : chosenOptionsSelected}\n                    onOptionSelect={this.onOptionSelect}\n                    onOptionCheck={(e, isChecked, itemData) => this.onTreeOptionCheck(e, isChecked, itemData, true)}\n                    actions={chosenOptionsActions}\n                    id={`${id || randomId}-chosen-pane`}\n                    isDisabled={isDisabled}\n                  />\n                </>\n              ) : (\n                children\n              )}\n            </div>\n          )}\n        </GenerateId>\n      </DualListSelectorContext.Provider>\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}