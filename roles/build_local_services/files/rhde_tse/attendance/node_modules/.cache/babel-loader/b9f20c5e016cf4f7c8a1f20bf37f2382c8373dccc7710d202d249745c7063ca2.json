{"ast":null,"code":"import * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId() {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pf';\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(func, wait) {\n  var _this = this;\n  let timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(_this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(container, element, partial) {\n  let strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(index, innerIndex, position, refsCollection, kids) {\n  let custom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function (item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, _ref) => {\n  let [breakpoint, value] = _ref;\n  return breakpoint === 'default' ? Object.assign(Object.assign({}, acc), {\n    [cssVar]: value\n  }) : Object.assign(Object.assign({}, acc), {\n    [`${cssVar}-on-${breakpoint}`]: value\n  });\n}, {});\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = function (mods, styles) {\n  let stylePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let breakpoint = arguments.length > 3 ? arguments[3] : undefined;\n  let vertical = arguments.length > 4 ? arguments[4] : undefined;\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint && !vertical) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];\n      }\n    }\n    return '';\n  }\n  return Object.entries(mods || {}).map(_ref2 => {\n    let [breakpoint, mod] = _ref2;\n    return `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}${vertical && breakpoint !== 'default' ? '-height' : ''}`;\n  }).map(toCamel).map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`)).map(modifierKey => styles.modifiers[modifierKey]).filter(Boolean).join(' ');\n};\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getVerticalBreakpoint = height => {\n  if (height === null) {\n    return null;\n  }\n  if (height >= globalHeightBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (height >= globalHeightBreakpoints.xl) {\n    return 'xl';\n  }\n  if (height >= globalHeightBreakpoints.lg) {\n    return 'lg';\n  }\n  if (height >= globalHeightBreakpoints.md) {\n    return 'md';\n  }\n  if (height >= globalHeightBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = width => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= globalWidthBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (width >= globalWidthBreakpoints.xl) {\n    return 'xl';\n  }\n  if (width >= globalWidthBreakpoints.lg) {\n    return 'lg';\n  }\n  if (width >= globalWidthBreakpoints.md) {\n    return 'md';\n  }\n  if (width >= globalWidthBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\nconst camelize = s => s.toUpperCase().replace('-', '').replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = s => s.replace(/([-_][a-z])/gi, camelize);\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text, node) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = node => {\n  const computedStyle = getComputedStyle(node);\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height,\n    width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node, value) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if (node.value) {\n      node.value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = events => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), {\n  [eventToPrevent]: event => {\n    event.preventDefault();\n  }\n}), {});","map":{"version":3,"names":["ReactDOM","globalWidthBreakpoints","globalHeightBreakpoints","SIDE","capitalize","input","toUpperCase","substring","getUniqueId","prefix","arguments","length","undefined","uid","Date","getTime","Math","random","toString","slice","debounce","func","wait","_this","timeout","_len","args","Array","_key","clearTimeout","setTimeout","apply","isElementInView","container","element","partial","strict","containerBounds","getBoundingClientRect","elementBounds","containerBoundsLeft","ceil","left","containerBoundsRight","floor","right","elementBoundsLeft","elementBoundsRight","isTotallyInView","isPartiallyInView","width","sideElementIsOutOfView","isOffLeft","isOffRight","side","NONE","BOTH","RIGHT","LEFT","fillTemplate","templateString","templateVars","replace","_","match","keyHandler","index","innerIndex","position","refsCollection","kids","custom","isArray","isMultiDimensional","filter","ref","constructor","nextIndex","nextInnerIndex","focus","findDOMNode","findTabbableElements","containerRef","tababbleSelectors","tabbable","current","querySelectorAll","list","prototype","call","item","tabIndex","getNextIndex","collection","pluralize","i","singular","plural","setBreakpointCssVars","mods","cssVar","Object","entries","reduce","acc","_ref","breakpoint","value","assign","formatBreakpointMods","styles","stylePrefix","vertical","modifiers","toCamel","breakpointsOrder","breakpointsIndex","indexOf","map","_ref2","mod","_res","group","modifierKey","Boolean","join","getVerticalBreakpoint","height","xl","lg","md","sm","getBreakpoint","camelize","s","canUseDOM","window","document","createElement","getTextWidth","text","node","computedStyle","getComputedStyle","getFontFromComputedStyle","computedFont","fontStretchLookupTable","fontStretch","fontStyle","fontVariant","fontWeight","fontSize","lineHeight","fontFamily","canvas","context","getContext","font","measureText","innerDimensions","clientWidth","clientHeight","parseFloat","paddingTop","paddingBottom","paddingLeft","paddingRight","trimLeft","availableWidth","newValue","innerText","preventedEvents","events","handlers","eventToPrevent","event","preventDefault"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\@patternfly\\react-core\\src\\helpers\\util.ts"],"sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input: string) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n  const uid =\n    new Date().getTime() +\n    Math.random()\n      .toString(36)\n      .slice(2);\n  return `${prefix}-${uid}`;\n}\n\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(this: any, func: (...args: any[]) => any, wait: number) {\n  let timeout: number;\n  return (...args: any[]) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait) as any;\n  };\n}\n\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(\n  container: HTMLElement,\n  element: HTMLElement,\n  partial: boolean,\n  strict: boolean = false\n): boolean {\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView =\n    (partial || (!strict && containerBounds.width < elementBounds.width)) &&\n    ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n      (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container: HTMLElement, element: HTMLElement): string {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString: string, templateVars: any) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(\n  index: number,\n  innerIndex: number,\n  position: string,\n  refsCollection: any[],\n  kids: any[],\n  custom = false\n) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (\n    refsCollection[nextIndex] === null ||\n    refsCollection[nextIndex] === undefined ||\n    (isMultiDimensional &&\n      (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))\n  ) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]) as HTMLElement;\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef: any, tababbleSelectors: string): any[] {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function(item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index: number, position: string, collection: any[]): number {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i: number, singular: string, plural?: string) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (\n  mods: {\n    default?: string;\n    sm?: string;\n    md?: string;\n    lg?: string;\n    xl?: string;\n    '2xl'?: string;\n    '3xl'?: string;\n  },\n  cssVar: string\n): React.CSSProperties =>\n  Object.entries(mods || {}).reduce(\n    (acc, [breakpoint, value]) =>\n      breakpoint === 'default' ? { ...acc, [cssVar]: value } : { ...acc, [`${cssVar}-on-${breakpoint}`]: value },\n    {}\n  );\n\nexport interface Mods {\n  default?: string;\n  sm?: string;\n  md?: string;\n  lg?: string;\n  xl?: string;\n  '2xl'?: string;\n  '3xl'?: string;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (\n  mods: Mods,\n  styles: any,\n  stylePrefix: string = '',\n  breakpoint?: 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl',\n  vertical?: boolean\n) => {\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint && !vertical) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint as keyof Mods]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i] as keyof Mods]}`)];\n      }\n    }\n    return '';\n  }\n\n  return Object.entries(mods || {})\n    .map(\n      ([breakpoint, mod]) =>\n        `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}${\n          vertical && breakpoint !== 'default' ? '-height' : ''\n        }`\n    )\n    .map(toCamel)\n    .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n    .map(modifierKey => styles.modifiers[modifierKey])\n    .filter(Boolean)\n    .join(' ');\n};\n\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getVerticalBreakpoint = (height: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (height === null) {\n    return null;\n  }\n  if (height >= globalHeightBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (height >= globalHeightBreakpoints.xl) {\n    return 'xl';\n  }\n  if (height >= globalHeightBreakpoints.lg) {\n    return 'lg';\n  }\n  if (height >= globalHeightBreakpoints.md) {\n    return 'md';\n  }\n  if (height >= globalHeightBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = (width: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= globalWidthBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (width >= globalWidthBreakpoints.xl) {\n    return 'xl';\n  }\n  if (width >= globalWidthBreakpoints.lg) {\n    return 'lg';\n  }\n  if (width >= globalWidthBreakpoints.md) {\n    return 'md';\n  }\n  if (width >= globalWidthBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n\nconst camelize = (s: string) =>\n  s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s: string) => s.replace(/([-_][a-z])/gi, camelize);\n\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text: string, node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = (fontStretchLookupTable as any)[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont =\n      computedStyle.fontStyle +\n      ' ' +\n      computedStyle.fontVariant +\n      ' ' +\n      computedStyle.fontWeight +\n      ' ' +\n      fontStretch +\n      ' ' +\n      computedStyle.fontSize +\n      '/' +\n      computedStyle.lineHeight +\n      ' ' +\n      computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n\n  return context.measureText(text).width;\n};\n\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return { height, width };\n};\n\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node: HTMLElement, value: string) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events: string[]) =>\n  events.reduce(\n    (handlers, eventToPrevent) => ({\n      ...handlers,\n      [eventToPrevent]: (event: React.SyntheticEvent<HTMLElement>) => {\n        event.preventDefault();\n      }\n    }),\n    {}\n  );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}