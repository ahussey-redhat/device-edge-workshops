{"ast":null,"code":"import { __rest } from \"tslib\";\nimport * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport { parseTime, validateTime, makeTimeOptions, amSuffix, pmSuffix, getHours, getMinutes, isWithinMinMax, getSeconds } from './TimePickerUtils';\nexport class TimePicker extends React.Component {\n  constructor(props) {\n    var _this;\n    super(props);\n    _this = this;\n    this.baseComponentRef = React.createRef();\n    this.toggleRef = React.createRef();\n    this.inputRef = React.createRef();\n    this.menuRef = React.createRef();\n    this.onDocClick = event => {\n      var _a, _b, _c, _d;\n      const clickedOnToggle = (_b = (_a = this.toggleRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target);\n      const clickedWithinMenu = (_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target);\n      if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n        this.onToggle(false);\n      }\n    };\n    this.handleGlobalKeys = event => {\n      var _a, _b, _c, _d;\n      const {\n        isTimeOptionsOpen,\n        focusedIndex,\n        scrollIndex\n      } = this.state;\n      // keyboard pressed while focus on toggle\n      if ((_b = (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)) {\n        if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n          this.onToggle(true);\n        } else if (isTimeOptionsOpen) {\n          if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n            this.onToggle(false);\n          } else if (event.key === KeyTypes.Enter) {\n            if (focusedIndex !== null) {\n              this.focusSelection(focusedIndex);\n              event.stopPropagation();\n            } else {\n              this.onToggle(false);\n            }\n          } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n            this.focusSelection(scrollIndex);\n            this.updateFocusedIndex(0);\n            event.preventDefault();\n          }\n        }\n        // keyboard pressed while focus on menu item\n      } else if ((_d = (_c = this.menuRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {\n        if (event.key === KeyTypes.ArrowDown) {\n          this.updateFocusedIndex(1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.ArrowUp) {\n          this.updateFocusedIndex(-1);\n          event.preventDefault();\n        } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.inputRef.current.focus();\n          this.onToggle(false);\n        }\n      }\n    };\n    this.updateFocusedIndex = increment => {\n      this.setState(prevState => {\n        const maxIndex = this.getOptions().length - 1;\n        let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n        if (nextIndex < 0) {\n          nextIndex = maxIndex;\n        } else if (nextIndex > maxIndex) {\n          nextIndex = 0;\n        }\n        this.scrollToIndex(nextIndex);\n        return {\n          focusedIndex: nextIndex\n        };\n      });\n    };\n    // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n    this.getIndexToScroll = index => {\n      if (this.props.menuAppendTo === 'inline') {\n        return index > 0 ? index - 1 : 0;\n      }\n      return index;\n    };\n    this.scrollToIndex = index => {\n      this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[this.getIndexToScroll(index)].offsetTop;\n    };\n    this.focusSelection = index => {\n      var _a;\n      const indexToFocus = index !== -1 ? index : 0;\n      if ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) {\n        this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`).focus();\n      }\n    };\n    this.scrollToSelection = time => {\n      const {\n        delimiter,\n        is24Hour\n      } = this.props;\n      let splitTime = time.split(this.props.delimiter);\n      let focusedIndex = null;\n      // build out the rest of the time assuming hh:00 if it's a partial time\n      if (splitTime.length < 2) {\n        time = `${time}${delimiter}00`;\n        splitTime = time.split(delimiter);\n        // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n      } else if (splitTime.length > 2) {\n        time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n        splitTime = time.split(delimiter);\n      }\n      // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n      if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n        const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n        time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      } else if (!is24Hour && splitTime.length > 1 && splitTime[1].length === 2 && !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) && !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n        time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n      }\n      let scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n      // if we found an exact match, scroll to match and return index of match for focus\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n        focusedIndex = scrollIndex;\n      } else if (splitTime.length === 2) {\n        // no exact match, scroll to closest hour but don't return index for focus\n        let amPm = '';\n        if (!is24Hour) {\n          if (splitTime[1].toUpperCase().includes('P')) {\n            amPm = pmSuffix;\n          } else if (splitTime[1].toUpperCase().includes('A')) {\n            amPm = amSuffix;\n          }\n        }\n        time = `${splitTime[0]}${delimiter}00${amPm}`;\n        scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n        if (scrollIndex !== -1) {\n          this.scrollToIndex(scrollIndex);\n        }\n      }\n      this.setState({\n        focusedIndex,\n        scrollIndex\n      });\n    };\n    this.getRegExp = function () {\n      let includeSeconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      const {\n        is24Hour,\n        delimiter\n      } = _this.props;\n      let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n      if (includeSeconds) {\n        baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n      }\n      return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n    };\n    this.getOptions = () => {\n      var _a;\n      return ((_a = this.menuRef) === null || _a === void 0 ? void 0 : _a.current) ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`)) : [];\n    };\n    this.isValidFormat = time => {\n      if (this.props.validateTime) {\n        return this.props.validateTime(time);\n      }\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds\n      } = this.props;\n      return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n    };\n    this.isValidTime = time => {\n      const {\n        delimiter,\n        includeSeconds\n      } = this.props;\n      const {\n        minTimeState,\n        maxTimeState\n      } = this.state;\n      return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n    };\n    this.isValid = time => this.isValidFormat(time) && this.isValidTime(time);\n    this.onToggle = isOpen => {\n      // on close, parse and validate input\n      this.setState(prevState => {\n        const {\n          timeRegex,\n          isInvalid,\n          timeState\n        } = prevState;\n        const {\n          delimiter,\n          is24Hour,\n          includeSeconds,\n          onChange\n        } = this.props;\n        const time = parseTime(timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n        // Call onChange when Enter is pressed in input and timeoption does not exist in menu\n        if (onChange && !isOpen && time !== timeState) {\n          onChange(null, time, getHours(time, timeRegex), getMinutes(time, timeRegex), getSeconds(time, timeRegex), this.isValid(time));\n        }\n        return {\n          isTimeOptionsOpen: isOpen,\n          timeState: time,\n          isInvalid: isOpen ? isInvalid : !this.isValid(time)\n        };\n      });\n      this.props.setIsOpen(isOpen);\n      if (!isOpen) {\n        this.inputRef.current.focus();\n      }\n    };\n    this.onSelect = e => {\n      const {\n        timeRegex,\n        timeState\n      } = this.state;\n      const {\n        delimiter,\n        is24Hour,\n        includeSeconds,\n        setIsOpen\n      } = this.props;\n      const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n      if (time !== timeState) {\n        this.onInputChange(time, e);\n      }\n      this.inputRef.current.focus();\n      this.setState({\n        isTimeOptionsOpen: false,\n        isInvalid: false\n      });\n      setIsOpen(false);\n    };\n    this.onInputClick = e => {\n      if (!this.state.isTimeOptionsOpen) {\n        this.onToggle(true);\n      }\n      e.stopPropagation();\n    };\n    this.onInputChange = (newTime, event) => {\n      const {\n        onChange\n      } = this.props;\n      const {\n        timeRegex\n      } = this.state;\n      if (onChange) {\n        onChange(event, newTime, getHours(newTime, timeRegex), getMinutes(newTime, timeRegex), getSeconds(newTime, timeRegex), this.isValid(newTime));\n      }\n      this.scrollToSelection(newTime);\n      this.setState({\n        timeState: newTime\n      });\n    };\n    const {\n      is24Hour,\n      delimiter,\n      time,\n      includeSeconds,\n      isOpen\n    } = this.props;\n    let {\n      minTime,\n      maxTime\n    } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n    this.setState({\n      isInvalid: !this.isValid(this.state.timeState)\n    });\n  }\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      timeRegex\n    } = this.state;\n    const {\n      time,\n      is24Hour,\n      delimiter,\n      includeSeconds,\n      isOpen,\n      minTime,\n      maxTime\n    } = this.props;\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      const parsedTime = parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds);\n      this.setState({\n        timeState: parsedTime,\n        isInvalid: !this.isValid(parsedTime)\n      });\n    }\n    if (minTime !== '' && minTime !== prevProps.minTime) {\n      this.setState({\n        minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n    if (maxTime !== '' && maxTime !== prevProps.maxTime) {\n      this.setState({\n        maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n  render() {\n    const _a = this.props,\n      {\n        'aria-label': ariaLabel,\n        isDisabled,\n        className,\n        placeholder,\n        id,\n        menuAppendTo,\n        is24Hour,\n        invalidFormatErrorMessage,\n        invalidMinMaxErrorMessage,\n        stepMinutes,\n        width,\n        delimiter,\n        inputProps,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        onChange,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        setIsOpen,\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        isOpen,\n        time,\n        validateTime,\n        minTime,\n        maxTime,\n        includeSeconds,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n        removeFindDomNode,\n        zIndex\n      } = _a,\n      props = __rest(_a, ['aria-label', \"isDisabled\", \"className\", \"placeholder\", \"id\", \"menuAppendTo\", \"is24Hour\", \"invalidFormatErrorMessage\", \"invalidMinMaxErrorMessage\", \"stepMinutes\", \"width\", \"delimiter\", \"inputProps\", \"onChange\", \"setIsOpen\", \"isOpen\", \"time\", \"validateTime\", \"minTime\", \"maxTime\", \"includeSeconds\", \"removeFindDomNode\", \"zIndex\"]);\n    const {\n      timeState,\n      isTimeOptionsOpen,\n      isInvalid,\n      minTimeState,\n      maxTimeState\n    } = this.state;\n    const style = {\n      '--pf-c-date-picker__input--c-form-control--Width': width\n    };\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n    const menuContainer = React.createElement(Menu, {\n      ref: this.menuRef,\n      isScrollable: true\n    }, React.createElement(MenuContent, {\n      maxMenuHeight: \"200px\"\n    }, React.createElement(MenuList, {\n      \"aria-label\": ariaLabel\n    }, options.map((option, index) => React.createElement(MenuItem, {\n      onClick: this.onSelect,\n      key: option,\n      id: `${randomId}-option-${index}`\n    }, option)))));\n    const textInput = React.createElement(TextInput, Object.assign({\n      \"aria-haspopup\": \"menu\",\n      className: css(formStyles.formControl),\n      id: `${randomId}-input`,\n      \"aria-label\": ariaLabel,\n      validated: isInvalid ? 'error' : 'default',\n      placeholder: placeholder,\n      value: timeState || '',\n      type: \"text\",\n      iconVariant: \"clock\",\n      onClick: this.onInputClick,\n      onChange: this.onInputChange,\n      autoComplete: \"off\",\n      isDisabled: isDisabled,\n      ref: this.inputRef\n    }, inputProps));\n    let calculatedAppendTo;\n    switch (menuAppendTo) {\n      case 'inline':\n        calculatedAppendTo = () => this.toggleRef.current;\n        break;\n      case 'parent':\n        calculatedAppendTo = getParentElement;\n        break;\n      default:\n        calculatedAppendTo = menuAppendTo;\n    }\n    return React.createElement(\"div\", {\n      ref: this.baseComponentRef,\n      className: css(datePickerStyles.datePicker, className)\n    }, React.createElement(\"div\", Object.assign({\n      className: css(datePickerStyles.datePickerInput),\n      style: style\n    }, props), React.createElement(InputGroup, null, React.createElement(\"div\", {\n      id: randomId\n    }, React.createElement(\"div\", {\n      ref: this.toggleRef,\n      style: {\n        paddingLeft: '0'\n      }\n    }, React.createElement(Popper, {\n      appendTo: calculatedAppendTo,\n      trigger: textInput,\n      popper: menuContainer,\n      isVisible: isTimeOptionsOpen,\n      removeFindDomNode: removeFindDomNode,\n      zIndex: zIndex\n    })))), isInvalid && React.createElement(\"div\", {\n      className: css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)\n    }, !isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage)));\n  }\n}\nTimePicker.displayName = 'TimePicker';\nTimePicker.defaultProps = {\n  className: '',\n  isDisabled: false,\n  time: '',\n  is24Hour: false,\n  invalidFormatErrorMessage: 'Invalid time format',\n  invalidMinMaxErrorMessage: 'Invalid time entered',\n  placeholder: 'hh:mm',\n  delimiter: ':',\n  'aria-label': 'Time picker',\n  width: '150px',\n  menuAppendTo: 'inline',\n  stepMinutes: 30,\n  inputProps: {},\n  minTime: '',\n  maxTime: '',\n  isOpen: false,\n  setIsOpen: () => {},\n  removeFindDomNode: false,\n  zIndex: 9999\n};","map":{"version":3,"names":["React","css","datePickerStyles","formStyles","menuStyles","getUniqueId","Popper","Menu","MenuContent","MenuList","MenuItem","InputGroup","TextInput","KeyTypes","parseTime","validateTime","makeTimeOptions","amSuffix","pmSuffix","getHours","getMinutes","isWithinMinMax","getSeconds","TimePicker","Component","constructor","props","_this","this","baseComponentRef","createRef","toggleRef","inputRef","menuRef","onDocClick","event","clickedOnToggle","_b","_a","current","contains","target","clickedWithinMenu","_d","_c","state","isTimeOptionsOpen","onToggle","handleGlobalKeys","focusedIndex","scrollIndex","key","Tab","Escape","Enter","focusSelection","stopPropagation","ArrowDown","ArrowUp","updateFocusedIndex","preventDefault","focus","increment","setState","prevState","maxIndex","getOptions","length","nextIndex","scrollToIndex","getIndexToScroll","index","menuAppendTo","closest","menuContent","scrollTop","offsetTop","indexToFocus","querySelector","menuItem","scrollToSelection","time","delimiter","is24Hour","splitTime","split","timeRegex","minutes","Date","toUpperCase","includes","trim","findIndex","option","textContent","amPm","getRegExp","includeSeconds","arguments","undefined","baseRegex","RegExp","Array","from","querySelectorAll","menuListItem","isValidFormat","isValidTime","minTimeState","maxTimeState","isValid","isOpen","isInvalid","timeState","onChange","setIsOpen","onSelect","e","onInputChange","onInputClick","newTime","minTime","maxTime","minSeconds","maxSeconds","componentDidMount","document","addEventListener","componentWillUnmount","removeEventListener","componentDidUpdate","prevProps","parsedTime","render","ariaLabel","isDisabled","className","placeholder","id","invalidFormatErrorMessage","invalidMinMaxErrorMessage","stepMinutes","width","inputProps","removeFindDomNode","zIndex","__rest","style","options","randomId","getParentElement","parentElement","menuContainer","createElement","ref","isScrollable","maxMenuHeight","map","onClick","textInput","Object","assign","formControl","validated","value","type","iconVariant","autoComplete","calculatedAppendTo","datePicker","datePickerInput","paddingLeft","appendTo","trigger","popper","isVisible","datePickerHelperText","modifiers","error","displayName","defaultProps"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\@patternfly\\react-core\\src\\components\\TimePicker\\TimePicker.tsx"],"sourcesContent":["import * as React from 'react';\nimport { css } from '@patternfly/react-styles';\nimport datePickerStyles from '@patternfly/react-styles/css/components/DatePicker/date-picker';\nimport formStyles from '@patternfly/react-styles/css/components/FormControl/form-control';\nimport menuStyles from '@patternfly/react-styles/css/components/Menu/menu';\nimport { getUniqueId } from '../../helpers';\nimport { Popper } from '../../helpers/Popper/Popper';\nimport { Menu, MenuContent, MenuList, MenuItem } from '../Menu';\nimport { InputGroup } from '../InputGroup';\nimport { TextInput, TextInputProps } from '../TextInput';\nimport { KeyTypes } from '../../helpers/constants';\nimport {\n  parseTime,\n  validateTime,\n  makeTimeOptions,\n  amSuffix,\n  pmSuffix,\n  getHours,\n  getMinutes,\n  isWithinMinMax,\n  getSeconds\n} from './TimePickerUtils';\n\nexport interface TimePickerProps\n  extends Omit<React.HTMLProps<HTMLDivElement>, 'onChange' | 'onFocus' | 'onBlur' | 'disabled' | 'ref'> {\n  /** Additional classes added to the time picker. */\n  className?: string;\n  /** Accessible label for the time picker */\n  'aria-label'?: string;\n  /** Flag indicating the time picker is disabled */\n  isDisabled?: boolean;\n  /** String to display in the empty time picker field as a hint for the expected time format */\n  placeholder?: string;\n  /** Character to display between the hour and minute */\n  delimiter?: string;\n  /** A time string. The format could be  an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  time?: string | Date;\n  /** Error message to display when the time is provided in an invalid format. */\n  invalidFormatErrorMessage?: string;\n  /** Error message to display when the time provided is not within the minTime/maxTime constriants */\n  invalidMinMaxErrorMessage?: string;\n  /** True if the time is 24 hour time. False if the time is 12 hour time */\n  is24Hour?: boolean;\n  /** Optional event handler called each time the value in the time picker input changes. */\n  onChange?: (\n    event: React.FormEvent<HTMLInputElement>,\n    time: string,\n    hour?: number,\n    minute?: number,\n    seconds?: number,\n    isValid?: boolean\n  ) => void;\n  /** Optional validator can be provided to override the internal time validator. */\n  validateTime?: (time: string) => boolean;\n  /** Id of the time picker */\n  id?: string;\n  /** Width of the time picker. */\n  width?: string;\n  /** The container to append the menu to. Defaults to 'inline'.\n   * If your menu is being cut off you can append it to an element higher up the DOM tree.\n   * Some examples:\n   * menuAppendTo=\"parent\"\n   * menuAppendTo={() => document.body}\n   * menuAppendTo={document.getElementById('target')}\n   */\n  menuAppendTo?: HTMLElement | (() => HTMLElement) | 'inline' | 'parent';\n  /** Size of step between time options in minutes.*/\n  stepMinutes?: number;\n  /** Additional props for input field */\n  inputProps?: TextInputProps;\n  /** A time string indicating the minimum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  minTime?: string | Date;\n  /** A time string indicating the maximum value allowed. The format could be an ISO 8601 formatted date string or in 'HH{delimiter}MM' format */\n  maxTime?: string | Date;\n  /** Includes number of seconds with the chosen time and allows users to manually edit the seconds value. */\n  includeSeconds?: boolean;\n  /** Flag to control the opened state of the time picker menu */\n  isOpen?: boolean;\n  /** Handler invoked each time the open state of time picker updates */\n  setIsOpen?: (isOpen?: boolean) => void;\n  /** @beta Opt-in for updated popper that does not use findDOMNode. */\n  removeFindDomNode?: boolean;\n  /** z-index of the time picker */\n  zIndex?: number;\n}\n\ninterface TimePickerState {\n  isInvalid: boolean;\n  isTimeOptionsOpen: boolean;\n  timeState: string;\n  focusedIndex: number;\n  scrollIndex: number;\n  timeRegex: RegExp;\n  minTimeState: string;\n  maxTimeState: string;\n}\n\nexport class TimePicker extends React.Component<TimePickerProps, TimePickerState> {\n  static displayName = 'TimePicker';\n  private baseComponentRef = React.createRef<any>();\n  private toggleRef = React.createRef<HTMLDivElement>();\n  private inputRef = React.createRef<HTMLInputElement>();\n  private menuRef = React.createRef<HTMLDivElement>();\n\n  static defaultProps = {\n    className: '',\n    isDisabled: false,\n    time: '',\n    is24Hour: false,\n    invalidFormatErrorMessage: 'Invalid time format',\n    invalidMinMaxErrorMessage: 'Invalid time entered',\n    placeholder: 'hh:mm',\n    delimiter: ':',\n    'aria-label': 'Time picker',\n    width: '150px',\n    menuAppendTo: 'inline',\n    stepMinutes: 30,\n    inputProps: {},\n    minTime: '',\n    maxTime: '',\n    isOpen: false,\n    setIsOpen: () => {},\n    removeFindDomNode: false,\n    zIndex: 9999\n  };\n\n  constructor(props: TimePickerProps) {\n    super(props);\n    const { is24Hour, delimiter, time, includeSeconds, isOpen } = this.props;\n    let { minTime, maxTime } = this.props;\n    if (minTime === '') {\n      const minSeconds = includeSeconds ? `${delimiter}00` : '';\n      minTime = is24Hour ? `00${delimiter}00${minSeconds}` : `12${delimiter}00${minSeconds} AM`;\n    }\n    if (maxTime === '') {\n      const maxSeconds = includeSeconds ? `${delimiter}59` : '';\n      maxTime = is24Hour ? `23${delimiter}59${maxSeconds}` : `11${delimiter}59${maxSeconds} PM`;\n    }\n    const timeRegex = this.getRegExp();\n    this.state = {\n      isInvalid: false,\n      isTimeOptionsOpen: isOpen,\n      timeState: parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds),\n      focusedIndex: null,\n      scrollIndex: 0,\n      timeRegex,\n      minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds),\n      maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n    };\n  }\n\n  componentDidMount() {\n    document.addEventListener('mousedown', this.onDocClick);\n    document.addEventListener('touchstart', this.onDocClick);\n    document.addEventListener('keydown', this.handleGlobalKeys);\n\n    this.setState({ isInvalid: !this.isValid(this.state.timeState) });\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousedown', this.onDocClick);\n    document.removeEventListener('touchstart', this.onDocClick);\n    document.removeEventListener('keydown', this.handleGlobalKeys);\n  }\n\n  onDocClick = (event: MouseEvent | TouchEvent) => {\n    const clickedOnToggle = this.toggleRef?.current?.contains(event.target as Node);\n    const clickedWithinMenu = this.menuRef?.current?.contains(event.target as Node);\n    if (this.state.isTimeOptionsOpen && !(clickedOnToggle || clickedWithinMenu)) {\n      this.onToggle(false);\n    }\n  };\n\n  handleGlobalKeys = (event: KeyboardEvent) => {\n    const { isTimeOptionsOpen, focusedIndex, scrollIndex } = this.state;\n    // keyboard pressed while focus on toggle\n    if (this.inputRef?.current?.contains(event.target as Node)) {\n      if (!isTimeOptionsOpen && event.key !== KeyTypes.Tab && event.key !== KeyTypes.Escape) {\n        this.onToggle(true);\n      } else if (isTimeOptionsOpen) {\n        if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n          this.onToggle(false);\n        } else if (event.key === KeyTypes.Enter) {\n          if (focusedIndex !== null) {\n            this.focusSelection(focusedIndex);\n            event.stopPropagation();\n          } else {\n            this.onToggle(false);\n          }\n        } else if (event.key === KeyTypes.ArrowDown || event.key === KeyTypes.ArrowUp) {\n          this.focusSelection(scrollIndex);\n          this.updateFocusedIndex(0);\n          event.preventDefault();\n        }\n      }\n      // keyboard pressed while focus on menu item\n    } else if (this.menuRef?.current?.contains(event.target as Node)) {\n      if (event.key === KeyTypes.ArrowDown) {\n        this.updateFocusedIndex(1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.ArrowUp) {\n        this.updateFocusedIndex(-1);\n        event.preventDefault();\n      } else if (event.key === KeyTypes.Escape || event.key === KeyTypes.Tab) {\n        this.inputRef.current.focus();\n        this.onToggle(false);\n      }\n    }\n  };\n\n  componentDidUpdate(prevProps: TimePickerProps, prevState: TimePickerState) {\n    const { timeState, isTimeOptionsOpen, isInvalid, timeRegex } = this.state;\n    const { time, is24Hour, delimiter, includeSeconds, isOpen, minTime, maxTime } = this.props;\n    if (prevProps.isOpen !== isOpen) {\n      this.onToggle(isOpen);\n    }\n\n    if (isTimeOptionsOpen && !prevState.isTimeOptionsOpen && timeState && !isInvalid) {\n      this.scrollToSelection(timeState);\n    }\n    if (delimiter !== prevProps.delimiter) {\n      this.setState({\n        timeRegex: this.getRegExp()\n      });\n    }\n    if (time !== '' && time !== prevProps.time) {\n      const parsedTime = parseTime(time, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      this.setState({\n        timeState: parsedTime,\n        isInvalid: !this.isValid(parsedTime)\n      });\n    }\n    if (minTime !== '' && minTime !== prevProps.minTime) {\n      this.setState({\n        minTimeState: parseTime(minTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n\n    if (maxTime !== '' && maxTime !== prevProps.maxTime) {\n      this.setState({\n        maxTimeState: parseTime(maxTime, timeRegex, delimiter, !is24Hour, includeSeconds)\n      });\n    }\n  }\n\n  updateFocusedIndex = (increment: number) => {\n    this.setState(prevState => {\n      const maxIndex = this.getOptions().length - 1;\n      let nextIndex =\n        prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex + increment;\n      if (nextIndex < 0) {\n        nextIndex = maxIndex;\n      } else if (nextIndex > maxIndex) {\n        nextIndex = 0;\n      }\n      this.scrollToIndex(nextIndex);\n      return {\n        focusedIndex: nextIndex\n      };\n    });\n  };\n\n  // fixes issue where menutAppendTo=\"inline\" results in the menu item that should be scrolled to being out of view; this will select the menu item that comes before the intended one, causing that before-item to be placed out of view instead\n  getIndexToScroll = (index: number) => {\n    if (this.props.menuAppendTo === 'inline') {\n      return index > 0 ? index - 1 : 0;\n    }\n    return index;\n  };\n\n  scrollToIndex = (index: number) => {\n    this.getOptions()[index].closest(`.${menuStyles.menuContent}`).scrollTop = this.getOptions()[\n      this.getIndexToScroll(index)\n    ].offsetTop;\n  };\n\n  focusSelection = (index: number) => {\n    const indexToFocus = index !== -1 ? index : 0;\n\n    if (this.menuRef?.current) {\n      (this.getOptions()[indexToFocus].querySelector(`.${menuStyles.menuItem}`) as HTMLElement).focus();\n    }\n  };\n\n  scrollToSelection = (time: string) => {\n    const { delimiter, is24Hour } = this.props;\n    let splitTime = time.split(this.props.delimiter);\n    let focusedIndex = null;\n\n    // build out the rest of the time assuming hh:00 if it's a partial time\n    if (splitTime.length < 2) {\n      time = `${time}${delimiter}00`;\n      splitTime = time.split(delimiter);\n      // due to only the input including seconds when includeSeconds=true, we need to build a temporary time here without those seconds so that an exact or close match can be scrolled to within the menu (which does not include seconds in any of the options)\n    } else if (splitTime.length > 2) {\n      time = parseTime(time, this.state.timeRegex, delimiter, !is24Hour, false);\n      splitTime = time.split(delimiter);\n    }\n\n    // for 12hr variant, autoscroll to pm if it's currently the afternoon, otherwise autoscroll to am\n    if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n      const minutes = splitTime[1].length === 0 ? '00' : splitTime[1] + '0';\n      time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    } else if (\n      !is24Hour &&\n      splitTime.length > 1 &&\n      splitTime[1].length === 2 &&\n      !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n      !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())\n    ) {\n      time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n    }\n    let scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n\n    // if we found an exact match, scroll to match and return index of match for focus\n    if (scrollIndex !== -1) {\n      this.scrollToIndex(scrollIndex);\n      focusedIndex = scrollIndex;\n    } else if (splitTime.length === 2) {\n      // no exact match, scroll to closest hour but don't return index for focus\n      let amPm = '';\n      if (!is24Hour) {\n        if (splitTime[1].toUpperCase().includes('P')) {\n          amPm = pmSuffix;\n        } else if (splitTime[1].toUpperCase().includes('A')) {\n          amPm = amSuffix;\n        }\n      }\n      time = `${splitTime[0]}${delimiter}00${amPm}`;\n      scrollIndex = this.getOptions().findIndex(option => option.textContent === time);\n      if (scrollIndex !== -1) {\n        this.scrollToIndex(scrollIndex);\n      }\n    }\n    this.setState({\n      focusedIndex,\n      scrollIndex\n    });\n  };\n\n  getRegExp = (includeSeconds: boolean = true) => {\n    const { is24Hour, delimiter } = this.props;\n    let baseRegex = `\\\\s*(\\\\d\\\\d?)${delimiter}([0-5]\\\\d)`;\n\n    if (includeSeconds) {\n      baseRegex += `${delimiter}?([0-5]\\\\d)?`;\n    }\n\n    return new RegExp(`^${baseRegex}${is24Hour ? '' : '\\\\s*([AaPp][Mm])?'}\\\\s*$`);\n  };\n\n  getOptions = () =>\n    (this.menuRef?.current\n      ? Array.from(this.menuRef.current.querySelectorAll(`.${menuStyles.menuListItem}`))\n      : []) as HTMLElement[];\n\n  isValidFormat = (time: string) => {\n    if (this.props.validateTime) {\n      return this.props.validateTime(time);\n    }\n\n    const { delimiter, is24Hour, includeSeconds } = this.props;\n    return validateTime(time, this.getRegExp(includeSeconds), delimiter, !is24Hour);\n  };\n\n  isValidTime = (time: string) => {\n    const { delimiter, includeSeconds } = this.props;\n    const { minTimeState, maxTimeState } = this.state;\n\n    return isWithinMinMax(minTimeState, maxTimeState, time, delimiter, includeSeconds);\n  };\n\n  isValid = (time: string) => this.isValidFormat(time) && this.isValidTime(time);\n\n  onToggle = (isOpen: boolean) => {\n    // on close, parse and validate input\n    this.setState(prevState => {\n      const { timeRegex, isInvalid, timeState } = prevState;\n      const { delimiter, is24Hour, includeSeconds, onChange } = this.props;\n      const time = parseTime(timeState, timeRegex, delimiter, !is24Hour, includeSeconds);\n\n      // Call onChange when Enter is pressed in input and timeoption does not exist in menu\n      if (onChange && !isOpen && time !== timeState) {\n        onChange(\n          null,\n          time,\n          getHours(time, timeRegex),\n          getMinutes(time, timeRegex),\n          getSeconds(time, timeRegex),\n          this.isValid(time)\n        );\n      }\n\n      return {\n        isTimeOptionsOpen: isOpen,\n        timeState: time,\n        isInvalid: isOpen ? isInvalid : !this.isValid(time)\n      };\n    });\n    this.props.setIsOpen(isOpen);\n    if (!isOpen) {\n      this.inputRef.current.focus();\n    }\n  };\n\n  onSelect = (e: any) => {\n    const { timeRegex, timeState } = this.state;\n    const { delimiter, is24Hour, includeSeconds, setIsOpen } = this.props;\n    const time = parseTime(e.target.textContent, timeRegex, delimiter, !is24Hour, includeSeconds);\n    if (time !== timeState) {\n      this.onInputChange(time, e);\n    }\n\n    this.inputRef.current.focus();\n    this.setState({\n      isTimeOptionsOpen: false,\n      isInvalid: false\n    });\n    setIsOpen(false);\n  };\n\n  onInputClick = (e: any) => {\n    if (!this.state.isTimeOptionsOpen) {\n      this.onToggle(true);\n    }\n    e.stopPropagation();\n  };\n\n  onInputChange = (newTime: string, event: React.FormEvent<HTMLInputElement>) => {\n    const { onChange } = this.props;\n    const { timeRegex } = this.state;\n    if (onChange) {\n      onChange(\n        event,\n        newTime,\n        getHours(newTime, timeRegex),\n        getMinutes(newTime, timeRegex),\n        getSeconds(newTime, timeRegex),\n        this.isValid(newTime)\n      );\n    }\n    this.scrollToSelection(newTime);\n    this.setState({\n      timeState: newTime\n    });\n  };\n\n  render() {\n    const {\n      'aria-label': ariaLabel,\n      isDisabled,\n      className,\n      placeholder,\n      id,\n      menuAppendTo,\n      is24Hour,\n      invalidFormatErrorMessage,\n      invalidMinMaxErrorMessage,\n      stepMinutes,\n      width,\n      delimiter,\n      inputProps,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      onChange,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      setIsOpen,\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      isOpen,\n      time,\n      validateTime,\n      minTime,\n      maxTime,\n      includeSeconds,\n      /* eslint-enable @typescript-eslint/no-unused-vars */\n      removeFindDomNode,\n      zIndex,\n      ...props\n    } = this.props;\n    const { timeState, isTimeOptionsOpen, isInvalid, minTimeState, maxTimeState } = this.state;\n    const style = { '--pf-c-date-picker__input--c-form-control--Width': width } as React.CSSProperties;\n    const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter, minTimeState, maxTimeState, includeSeconds);\n    const isValidFormat = this.isValidFormat(timeState);\n    const randomId = id || getUniqueId('time-picker');\n\n    const getParentElement = () => {\n      if (this.baseComponentRef && this.baseComponentRef.current) {\n        return this.baseComponentRef.current.parentElement;\n      }\n      return null;\n    };\n\n    const menuContainer = (\n      <Menu ref={this.menuRef} isScrollable>\n        <MenuContent maxMenuHeight=\"200px\">\n          <MenuList aria-label={ariaLabel}>\n            {options.map((option, index) => (\n              <MenuItem onClick={this.onSelect} key={option} id={`${randomId}-option-${index}`}>\n                {option}\n              </MenuItem>\n            ))}\n          </MenuList>\n        </MenuContent>\n      </Menu>\n    );\n\n    const textInput = (\n      <TextInput\n        aria-haspopup=\"menu\"\n        className={css(formStyles.formControl)}\n        id={`${randomId}-input`}\n        aria-label={ariaLabel}\n        validated={isInvalid ? 'error' : 'default'}\n        placeholder={placeholder}\n        value={timeState || ''}\n        type=\"text\"\n        iconVariant=\"clock\"\n        onClick={this.onInputClick}\n        onChange={this.onInputChange}\n        autoComplete=\"off\"\n        isDisabled={isDisabled}\n        ref={this.inputRef}\n        {...inputProps}\n      />\n    );\n\n    let calculatedAppendTo;\n    switch (menuAppendTo) {\n      case 'inline':\n        calculatedAppendTo = () => this.toggleRef.current;\n        break;\n      case 'parent':\n        calculatedAppendTo = getParentElement;\n        break;\n      default:\n        calculatedAppendTo = menuAppendTo as HTMLElement;\n    }\n\n    return (\n      <div ref={this.baseComponentRef} className={css(datePickerStyles.datePicker, className)}>\n        <div className={css(datePickerStyles.datePickerInput)} style={style} {...props}>\n          <InputGroup>\n            <div id={randomId}>\n              <div ref={this.toggleRef} style={{ paddingLeft: '0' }}>\n                <Popper\n                  appendTo={calculatedAppendTo}\n                  trigger={textInput}\n                  popper={menuContainer}\n                  isVisible={isTimeOptionsOpen}\n                  removeFindDomNode={removeFindDomNode}\n                  zIndex={zIndex}\n                />\n              </div>\n            </div>\n          </InputGroup>\n          {isInvalid && (\n            <div className={css(datePickerStyles.datePickerHelperText, datePickerStyles.modifiers.error)}>\n              {!isValidFormat ? invalidFormatErrorMessage : invalidMinMaxErrorMessage}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}