{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  const altContext = elementContext === popper ? reference : popper;\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  const offsetData = state.modifiersData.offset;\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}","map":{"version":3,"names":["getBoundingClientRect","getClippingRect","getDocumentElement","computeOffsets","rectToClientRect","clippingParents","reference","popper","bottom","top","right","basePlacements","viewport","isElement","mergePaddingObject","expandToHashMap","detectOverflow","state","options","arguments","length","undefined","placement","boundary","rootBoundary","elementContext","altBoundary","padding","paddingObject","altContext","referenceElement","elements","popperRect","rects","element","clippingClientRect","contextElement","referenceClientRect","popperOffsets","strategy","popperClientRect","Object","assign","elementClientRect","overflowOffsets","left","offsetData","modifiersData","offset","keys","forEach","key","multiply","indexOf","axis"],"sources":["C:\\work\\Demo\\device-edge-workshops\\roles\\build_local_services\\files\\rhde_tse\\attendance\\node_modules\\@patternfly\\react-core\\src\\helpers\\Popper\\thirdparty\\popper-core\\utils\\detectOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, SideObject, Padding } from '../types';\nimport { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  placement: Placement;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  elementContext: Context;\n  altBoundary: boolean;\n  padding: Padding;\n}\n\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state: State, options: Partial<Options> = {}): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets\n  });\n\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}